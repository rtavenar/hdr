<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,minimum-scale=1">

  <title>Machine Learning for Time Series</title>
  <meta name="description" content="# DTW with Global Invariances**Note.** This work was part of Titouan Vayer's PhD thesis.We were co-supervising Titouan together with Laetitia Chapel and Nico...">

  <link rel="canonical" href="https://rtavenar.github.io/hdr/content/parts/01/dtw/dtw_gi.html">
  <link rel="alternate" type="application/rss+xml" title="Machine Learning for Time Series" href="https://rtavenar.github.io/hdr/feed.xml">

  <meta property="og:url"         content="https://rtavenar.github.io/hdr/content/parts/01/dtw/dtw_gi.html" />
<meta property="og:type"        content="article" />
<meta property="og:title"       content="Machine Learning for Time Series" />
<meta property="og:description" content="# DTW with Global Invariances**Note.** This work was part of Titouan Vayer's PhD thesis.We were co-supervising Titouan together with Laetitia Chapel and Nico..." />
<meta property="og:image"       content="https://rtavenar.github.io/hdr/false" />

<meta name="twitter:card" content="summary">


  <script type="application/ld+json">
  {
  "@context": "http://schema.org",
  "@type": "NewsArticle",
  "mainEntityOfPage": "https://rtavenar.github.io/hdr/content/parts/01/dtw/dtw_gi.html",
  "headline": "Machine Learning for Time Series",
  "datePublished": "2020-05-05T17:15:30+02:00",
  "dateModified": "2020-05-05T17:15:30+02:00",
  "description": "# DTW with Global Invariances**Note.** This work was part of Titouan Vayer's PhD thesis.We were co-supervising Titouan together with Laetitia Chapel and Nico...",
  "author": {
    "@type": "Person",
    "name": "Romain Tavenard"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Data 100 at UC Berkeley",
    "logo": {
      "@type": "ImageObject",
      "url": "https://rtavenar.github.io/hdr",
      "width": 60,
      "height": 60
    }
  },
  "image": {
    "@type": "ImageObject",
    "url": "https://rtavenar.github.io/hdr",
    "height": 60,
    "width": 60
  }
}

  </script>
  <link rel="stylesheet" href="/hdr/assets/css/styles.css">

  <!-- <link rel="manifest" href="/manifest.json"> -->
  <!-- <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#efae0a"> -->
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-TileImage" content="/mstile-144x144.png">
  <meta name="theme-color" content="#233947">

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/x-icon" href="/hdr/images/logo/favicon.ico">

  <!-- MathJax Config -->
  <!-- Allow inline math using $ and automatically break long math lines -->
<!-- (mostly) copied from nbconvert configuration -->
<!-- https://github.com/jupyter/nbconvert/blob/master/nbconvert/templates/html/mathjax.tpl -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
        processEnvironments: true
    },
    // Center justify equations in code and markdown cells. Elsewhere
    // we use CSS to left justify single line equations in code cells.
    displayAlign: 'center',
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}},
        linebreaks: { automatic: true },
    },
    
    // Number LaTeX-style equations
    "TeX": {
        equationNumbers: {
          autoNumber: "all"
        }
    }
    
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML' async></script>


  <!-- DOM updating function -->
  <script src="/hdr/assets/js/page/dom-update.js"></script>

  <!-- Selectors for elements on the page -->
  <script src="/hdr/assets/js/page/documentSelectors.js"></script>

  <!-- Define some javascript variables that will be useful in other javascript -->
  <script>
    const site_basename = '/hdr';
  </script>

  <!-- Add AnchorJS to let headers be linked -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.0/anchor.min.js" async></script>
  <script src="/hdr/assets/js/page/anchors.js" async></script>

  <!-- Include Turbolinks to make page loads fast -->
  <!-- https://github.com/turbolinks/turbolinks -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/turbolinks/5.2.0/turbolinks.js" async></script>
  <meta name="turbolinks-cache-control" content="no-cache">

  <!-- Load nbinteract for widgets -->
  

  <!-- Load Thebelab for interactive widgets -->
  <!-- Include Thebelab for interactive code if it's enabled -->


<!-- Display Thebelab button in each code cell -->
<script>
/**
 * Set up thebelab button for code blocks
 */

const thebelabCellButton = id =>
  `<a id="thebelab-cell-button-${id}" class="btn thebebtn o-tooltip--left" data-tooltip="Interactive Mode">
    <img src="/hdr/assets/images/edit-button.svg" alt="Start thebelab interactive mode">
  </a>`


const addThebelabButtonToCodeCells =  () => {

  const codeCells = document.querySelectorAll('div.input_area > div.highlight:not(.output) pre')
  codeCells.forEach((codeCell, index) => {
    const id = codeCellId(index)
    codeCell.setAttribute('id', id)
    if (document.getElementById("thebelab-cell-button-" + id) == null) {
      codeCell.insertAdjacentHTML('afterend', thebelabCellButton(id));
    }
  })
}

initFunction(addThebelabButtonToCodeCells);
</script>


<script src="https://unpkg.com/thebelab@latest/lib/index.js" async></script>
<script>
    /**
     * Add attributes to Thebelab blocks
     */

    const initThebelab = () => {
        const addThebelabToCodeCells = () => {
            console.log("Adding thebelab to code cells...");
            // If Thebelab hasn't loaded, wait a bit and try again. This
            // happens because we load ClipboardJS asynchronously.
            if (window.thebelab === undefined) {
                setTimeout(addThebelabToCodeCells, 250)
            return
            }

            // If we already detect a Thebelab cell, don't re-run
            if (document.querySelectorAll('div.thebelab-cell').length > 0) {
                return;
            }

            // Find all code cells, replace with Thebelab interactive code cells
            const codeCells = document.querySelectorAll('.input_area pre')
            codeCells.forEach((codeCell, index) => {
                const id = codeCellId(index)

                // Clean up the language to make it work w/ CodeMirror and add it to the cell
                dataLanguage = ""
                dataLanguage = detectLanguage(dataLanguage);
                codeCell.setAttribute('data-language', dataLanguage)
                codeCell.setAttribute('data-executable', 'true')

                // If the code cell is hidden, show it
                var inputCheckbox = document.querySelector(`input#hidebtn${codeCell.id}`);
                if (inputCheckbox !== null) {
                    setCodeCellVisibility(inputCheckbox, 'visible');
                }
            });

            // Remove the event listener from the page so keyboard press doesn't
            // Change page
            document.removeEventListener('keydown', initPageNav)
            keyboardListener = false;

            // Init thebelab
            thebelab.bootstrap();

            // Remove copy buttons since they won't work anymore
            const copyAndThebeButtons = document.querySelectorAll('.copybtn, .thebebtn')
            copyAndThebeButtons.forEach((button, index) => {
                button.remove();
            });

            // Remove outputs since they'll be stale
            const outputs = document.querySelectorAll('.output *, .output')
            outputs.forEach((output, index) => {
                output.remove();
            });

            // Find any cells with an initialization tag and ask ThebeLab to run them when ready
            var thebeInitCells = document.querySelectorAll('div.tag_thebelab-init');
            thebeInitCells.forEach((cell) => {
                console.log("Initializing ThebeLab with cell: " + cell.id);
                cell.querySelector('.thebelab-run-button').click();
            });
        }

        // Add event listener for the function to modify code cells
        const thebelabButtons = document.querySelectorAll('[id^=thebelab], [id$=thebelab]')
        thebelabButtons.forEach((thebelabButton,index) => {
            if (thebelabButton === null) {
                setTimeout(initThebelab, 250)
                return
            };
            thebelabButton.addEventListener('click', addThebelabToCodeCells);
        });
    }

    // Initialize Thebelab
    initFunction(initThebelab);

// Helper function to munge the language name
var detectLanguage = (language) => {
    if (language.indexOf('python') > -1) {
        language = "python";
    }
    return language;
}
</script>



  <!-- Load the auto-generating TOC (non-async otherwise the TOC won't load w/ turbolinks) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.8.1/tocbot.min.js" async></script>
  <script src="/hdr/assets/js/page/tocbot.js"></script>

  <!-- Google analytics -->
  


  <!-- Clipboard copy button -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script>

  <!-- Load custom website scripts -->
  <script src="/hdr/assets/js/scripts.js" async></script>

  <!-- Load custom user CSS and JS  -->
  <script src="/hdr/assets/custom/custom.js" async></script>
  <link rel="stylesheet" href="/hdr/assets/custom/custom.css">

  <!-- Update interact links w/ REST param, is defined in includes so we can use templates -->
  
<script>
/**
  * To auto-embed hub URLs in interact links if given in a RESTful fashion
 */

function getJsonFromUrl(url) {
  var query = url.split('?');
  if (query.length < 2) {
    // No queries so just return false
    return false;
  }
  query = query[1];
  // Collect REST params into a dictionary
  var result = {};
  query.split("&").forEach(function(part) {
    var item = part.split("=");
    result[item[0]] = decodeURIComponent(item[1]);
  });
  return result;
}
    
function dict2param(dict) {
    params = Object.keys(dict).map(function(k) {
        return encodeURIComponent(k) + '=' + encodeURIComponent(dict[k])
    });
    return params.join('&')
}

// Parse a Binder URL, converting it to the string needed for JupyterHub
function binder2Jupyterhub(url) {
  newUrl = {};
  parts = url.split('v2/gh/')[1];
  // Grab the base repo information
  repoinfo = parts.split('?')[0];
  var [org, repo, ref] = repoinfo.split('/');
  newUrl['repo'] = ['https://github.com', org, repo].join('/');
  newUrl['branch'] = ref
  // Grab extra parameters passed
  params = getJsonFromUrl(url);
  if (params['filepath'] !== undefined) {
    newUrl['subPath'] = params['filepath']
  }
  return dict2param(newUrl);
}

// Filter out potentially unsafe characters to prevent xss
function safeUrl(url)
{
   return String(encodeURIComponent(url))
            .replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
}

function addParamToInternalLinks(hub) {
  var links = document.querySelectorAll("a").forEach(function(link) {
    var href = link.href;
    // If the link is an internal link...
    if (href.search("https://rtavenar.github.io") !== -1 || href.startsWith('/') || href.search("127.0.0.1:") !== -1) {
      // Assume we're an internal link, add the hub param to it
      var params = getJsonFromUrl(href);
      if (params !== false) {
        // We have REST params, so append a new one
        params['jupyterhub'] = hub;
      } else {
        // Create the REST params
        params = {'jupyterhub': hub};
      }
      // Update the link
      var newHref = href.split('?')[0] + '?' + dict2param(params);
      link.setAttribute('href', decodeURIComponent(newHref));
    }
  });
  return false;
}


// Update interact links
function updateInteractLink() {
    // hack to make this work since it expects a ? in the URL
    rest = getJsonFromUrl("?" + location.search.substr(1));
    jupyterHubUrl = rest['jupyterhub'];
    var hubType = null;
    var hubUrl = null;
    if (jupyterHubUrl !== undefined) {
      hubType = 'jupyterhub';
      hubUrl = jupyterHubUrl;
    }

    if (hubType !== null) {
      // Sanitize the hubUrl
      hubUrl = safeUrl(hubUrl);

      // Add HTTP text if omitted
      if (hubUrl.indexOf('http') < 0) {hubUrl = 'http://' + hubUrl;}
      var interactButtons = document.querySelectorAll("button.interact-button")
      var lastButton = interactButtons[interactButtons.length-1];
      var link = lastButton.parentElement;

      // If we've already run this, skip the link updating
      if (link.nextElementSibling !== null) {
        return;
      }

      // Update the link and add context div
      var href = link.getAttribute('href');
      if (lastButton.id === 'interact-button-binder') {
        // If binder links exist, we need to re-work them for jupyterhub
        if (hubUrl.indexOf('http%3A%2F%2Flocalhost') > -1) {
          // If localhost, assume we're working from a local Jupyter server and remove `/hub`
          first = [hubUrl, 'git-sync'].join('/')
        } else {
          first = [hubUrl, 'hub', 'user-redirect', 'git-sync'].join('/')
        }
        href = first + '?' + binder2Jupyterhub(href);
      } else {
        // If interact button isn't binderhub, assume it's jupyterhub
        // If JupyterHub links, we only need to replace the hub url
        href = href.replace("", hubUrl);
        if (hubUrl.indexOf('http%3A%2F%2Flocalhost') > -1) {
          // Assume we're working from a local Jupyter server and remove `/hub`
          href = href.replace("/hub/user-redirect", "");
        }
      }
      link.setAttribute('href', decodeURIComponent(href));

      // Add text after interact link saying where we're launching
      hubUrlNoHttp = decodeURIComponent(hubUrl).replace('http://', '').replace('https://', '');
      link.insertAdjacentHTML('afterend', '<div class="interact-context">on ' + hubUrlNoHttp + '</div>');

      // Update internal links so we retain the hub url
      addParamToInternalLinks(hubUrl);
    }
}

runWhenDOMLoaded(updateInteractLink)
document.addEventListener('turbolinks:load', updateInteractLink)
</script>


  <!-- Lunr search code - will only be executed on the /search page -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js" async></script>
  <script>var initQuery = function() {
  // See if we have a search box
  var searchInput = document.querySelector('input#lunr_search');
  if (searchInput === null) {
    return;
  }

  // Function to parse our lunr cache
  var idx = lunr(function () {
    this.field('title')
    this.field('excerpt')
    this.field('categories')
    this.field('tags')
    this.ref('id')

    this.pipeline.remove(lunr.trimmer)

    for (var item in store) {
      this.add({
        title: store[item].title,
        excerpt: store[item].excerpt,
        categories: store[item].categories,
        tags: store[item].tags,
        id: item
      })
    }
  });

  // Run search upon keyup
  searchInput.addEventListener('keyup', function () {
    var resultdiv = document.querySelector('#results');
    var query = document.querySelector("input#lunr_search").value.toLowerCase();
    var result =
      idx.query(function (q) {
        query.split(lunr.tokenizer.separator).forEach(function (term) {
          q.term(term, { boost: 100 })
          if(query.lastIndexOf(" ") != query.length-1){
            q.term(term, {  usePipeline: false, wildcard: lunr.Query.wildcard.TRAILING, boost: 10 })
          }
          if (term != ""){
            q.term(term, {  usePipeline: false, editDistance: 1, boost: 1 })
          }
        })
      });

      // Empty the results div
      while (resultdiv.firstChild) {
        resultdiv.removeChild(resultdiv.firstChild);
      }

    resultdiv.insertAdjacentHTML('afterbegin', '<p class="results__found">'+result.length+' Result(s) found</p>');
    for (var item in result) {
      var ref = result[item].ref;
      if(store[ref].teaser){
        var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<div class="archive__item-teaser">'+
                '<img src="'+store[ref].teaser+'" alt="">'+
              '</div>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      else{
    	  var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      resultdiv.insertAdjacentHTML('beforeend', searchitem);
    }
  });
};

initFunction(initQuery);
</script>

  <!-- Load JS that depends on site variables -->
  <script src="/hdr/assets/js/page/copy-button.js" async></script>

  <!-- Hide cell code -->
  <script src="/hdr/assets/js/page/hide-cell.js" async></script>

  <!-- Printing the screen -->
  <!-- Include nbinteract for interactive widgets -->
<script src="https://printjs-4de6.kxcdn.com/print.min.js" async></script>
<script>
printContent = () => {
    // MathJax displays a second version of any math for assistive devices etc.
    // This prevents double-rendering in the PDF output.
    var ignoreAssistList = [];
    assistives = document.querySelectorAll('.MathJax_Display span.MJX_Assistive_MathML').forEach((element, index) => {
        var thisId = 'MathJax-assistive-' + index.toString();
        element.setAttribute('id', thisId);
        ignoreAssistList.push(thisId)
    });

    // Print the actual content object
    printJS({
        printable: 'textbook_content',
        type: 'html',
        css: "/hdr/assets/css/styles.css",
        style: "#textbook_content {padding-top: 40px};",
        scanStyles: false,
        targetStyles: ["*"],
        ignoreElements: ignoreAssistList,
        documentTitle: "Made with Jupyter Book"
    })
};

initPrint = () => {
    document.querySelector('#interact-button-print').addEventListener('click', printContent)
}

initFunction(initPrint)
</script>

</head>

  <body>
    <!-- Include the ThebeLab config so it gets reloaded on each page -->
    <script type="text/x-thebe-config">{
    requestKernel: true,
    binderOptions: {
    repo: "rtavenar/hdr",
    ref: "gh-pages",
    },
    codeMirrorConfig: {
    theme: "abcdef",
    mode: "python"
    },
    kernelOptions: {
    kernelName: "python3",
    path: ""
    }
}
</script>

    <!-- .js-show-sidebar shows sidebar by default -->
    <div id="js-textbook" class="c-textbook js-show-sidebar">
      



<nav id="js-sidebar" class="c-textbook__sidebar">
  
  <h2 class="c-sidebar__title">Machine Learning for Time Series</h2>
  <ul class="c-sidebar__chapters">
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/parts/about">
        <a class="c-sidebar__entry"
          href="/hdr/parts/about.html"
        >
          
          About this document
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/parts/intro">
        <a class="c-sidebar__entry"
          href="/hdr/parts/intro.html"
        >
          
          Introduction
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/parts/01_metrics">
        <a class="c-sidebar__entry"
          href="/hdr/parts/01_metrics.html"
        >
          
            1.
          
          Defining adequate metrics for structured data
        </a>
      </li>

      
      

      

      
      

      
        

        

        <ul class="c-sidebar__sections">
          
            
            

            
            
            
            

            <li class="c-sidebar__section" data-url="/parts/01/temporal_kernel">
              <a class="c-sidebar__entry"
                href="/hdr/parts/01/temporal_kernel.html"
              >
                
                  1.1
                
                A Temporal Kernel for Time Series
              </a>
            </li>
            
            
          
            
            

            
            
            
            

            <li class="c-sidebar__section" data-url="/parts/01/dtw">
              <a class="c-sidebar__entry"
                href="/hdr/parts/01/dtw.html"
              >
                
                  1.2
                
                Dynamic Time Warping
              </a>
            </li>
            
              
              <ul class='c-sidebar__subsections'>
              
                
                
                
                
                <li class="c-sidebar__subsection" data-url="/parts/01/dtw/dtw_warping_length">
                  <a class="c-sidebar__entry"
                    href="/hdr/parts/01/dtw/dtw_warping_length.html"
                  >
                    
                      1.2.1
                      
                    
                    Constrained Dynamic Time Warping
                  </a>
                </li>
              
                
                
                
                
                <li class="c-sidebar__subsection" data-url="/parts/01/dtw/dtw_da">
                  <a class="c-sidebar__entry"
                    href="/hdr/parts/01/dtw/dtw_da.html"
                  >
                    
                      1.2.2
                      
                    
                    DTW alignment as an adaptive resampling strategy
                  </a>
                </li>
              
                
                
                
                
                <li class="c-sidebar__subsection" data-url="/parts/01/dtw/dtw_gi">
                  <a class="c-sidebar__entry"
                    href="/hdr/parts/01/dtw/dtw_gi.html"
                  >
                    
                      1.2.3
                      
                    
                    DTW with Global Invariances
                  </a>
                </li>
              
              </ul>
            
            
          
            
            

            
            
            
            

            <li class="c-sidebar__section" data-url="/parts/01/ot">
              <a class="c-sidebar__entry"
                href="/hdr/parts/01/ot.html"
              >
                
                  1.3
                
                Optimal Transport for Structured Data
              </a>
            </li>
            
            
          
        </ul>
      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/parts/02_representations">
        <a class="c-sidebar__entry"
          href="/hdr/parts/02_representations.html"
        >
          
            2.
          
          Learning sensible representations for time series
        </a>
      </li>

      
      

      

      
      

      
        

        

        <ul class="c-sidebar__sections">
          
            
            

            
            
            
            

            <li class="c-sidebar__section" data-url="/parts/02/topic_models">
              <a class="c-sidebar__entry"
                href="/hdr/parts/02/topic_models.html"
              >
                
                  2.1
                
                Temporal Topic Models
              </a>
            </li>
            
            
          
            
            

            
            
            
            

            <li class="c-sidebar__section" data-url="/parts/02/shapelets_cnn">
              <a class="c-sidebar__entry"
                href="/hdr/parts/02/shapelets_cnn.html"
              >
                
                  2.2
                
                Shapelet-based Representations and Convolutional Models
              </a>
            </li>
            
            
          
            
            

            
            
            
            

            <li class="c-sidebar__section" data-url="/parts/02/early">
              <a class="c-sidebar__entry"
                href="/hdr/parts/02/early.html"
              >
                
                  2.3
                
                Early Classification of Time Series
              </a>
            </li>
            
            
          
        </ul>
      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/parts/conclu">
        <a class="c-sidebar__entry"
          href="/hdr/parts/conclu.html"
        >
          
          Conclusion and Perspectives
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      
        <li class="c-sidebar__divider"></li>
        
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/contributing">
        <a class="c-sidebar__entry"
          href="/hdr/contributing.html"
        >
          
          Feedback welcome
        </a>
      </li>

      
      

      

      
      

      

      
    
  </ul>
  <p class="sidebar_footer">Romain Tavenard's HDR thesis.<br />Powered by <a href='https://jupyterbook.org'>Jupyter Book</a>.</p>
</nav>

      
      <div class="c-topbar" id="top-navbar">
  <!-- We show the sidebar by default so we use .is-active -->
  <div class="c-topbar__buttons">
    <button
      id="js-sidebar-toggle"
      class="hamburger hamburger--arrowalt is-active"
    >
      <span class="hamburger-box">
        <span class="hamburger-inner"></span>
      </span>
    </button>
    <div class="buttons">
<div class="download-buttons-dropdown">
    <button id="dropdown-button-trigger" class="interact-button"><img src="/hdr/assets/images/download-solid.svg" alt="Download" /></button>
    <div class="download-buttons">
        
        <a id="interact-button-print"><button id="interact-button-download" class="interact-button">.pdf</button></a>
    </div>
</div>


</div>

  </div>
  <!-- Empty sidebar placeholder that we'll auto-fill with javascript -->
  <aside class="sidebar__right">
    <header><h4 class="nav__title"><img src="/hdr/assets/images/list-solid.svg" alt="Search" />   On this page</h4></header>
    <nav class="onthispage">
    </nav>
  </aside>
  <a href="/hdr/search.html" class="topbar-right-button" id="search-button">
    <img src="/hdr/assets/images/search-solid.svg" alt="Search" />
  </a>
</div>

      <main class="c-textbook__page" tabindex="-1">
            <div class="c-textbook__content" id="textbook_content">
              <h1 id="dtw-with-global-invariances">DTW with Global Invariances</h1>

<!-- #region {"tags": ["popout"]} -->
<p><strong>Note.</strong> This work was part of Titouan Vayer’s PhD thesis.
We were co-supervising Titouan together with Laetitia Chapel and Nicolas Courty.
<!-- #endregion --></p>

<p>In this work we address the problem of comparing time series while taking
into account both feature space transformation and temporal variability.
The proposed framework combines a latent global transformation of the feature
space with the widely used Dynamic Time Warping (DTW).
This work is available as preprint <a class="citation" href="#vayer2020time">(Vayer et al., 2020)</a>.</p>

<h2 id="definition">Definition</h2>

<p>Let $\mathbf{x}$ and $\mathbf{x^\prime}$ be two time series of respective
lengths $n$ and $m$.
Here, features from both time series are not assumed to lie in the same ambient
space, but it is assumed that features from $\mathbf{x}$ lie in $\mathbb{R}^p$
while features from $\mathbf{x^\prime}$ lie in $\mathbb{R}^{p’}$
In the following, we assume $p \geq p’$ without loss of generality.
In order to allow comparison between time series $\mathbf{x}$ and
$\mathbf{x^\prime}$,
we will optimize on a family of functions $\mathcal{F}$ that map features from
$\mathbf{x^\prime}$ onto the feature space in which features from $\mathbf{x}$
lie. More formally, we define Dynamic Time Warping with Global Invariances
(DTW-GI) as the solution of the following joint optimization problem:</p>

<p>\begin{equation}
    \text{DTW-GI}(\mathbf{x}, \mathbf{x^\prime}) =
        \sqrt{
            \min_{f \in \mathcal{F}, \pi \in \mathcal{A}(\mathbf{x}, \mathbf{x^\prime})}
                \sum_{(i, j) \in \pi} d(x_i, f(x^\prime_j))^2
        } ,
    \label{eq:dtwgi}
\end{equation}</p>

<p>where $\mathcal{F}$ is a family of functions from $\mathbb{R}^{p^\prime}$ to
$\mathbb{R}^{p}$.</p>

<p>This similarity measure estimates both temporal alignment and feature space
transformation between time series simultaneously, allowing the alignment of
time series when the similarity should be defined up to a global transformation.
Time series do not have to lie in the same ambient space, as presented in the
following Figure:</p>

<figure>
<p><img src="../../../images/tex/dtw_gi.svg" alt="" /></p>
  <figcaption>DTW-GI aligns time series by optimizing on temporal alignment
   (through Dynamic Time Warping) and feature space transformation (denoted
   $f$ here). Time series represented here are color-coded trajectories, whose
   starting (resp. end) point is depicted in blue (resp. red).</figcaption>
</figure>

<h2 id="optimization">Optimization</h2>

<p>Optimization of the quantity in Equation \eqref{eq:dtwgi} can be performed
<em>via</em> Block Coordinate Descent.
In a nutshell, optimization alternates between the following two steps:</p>

<ol>
  <li>for a fixed $f$, determine the optimal alignment path $\pi$ using the DTW
algorithm;</li>
  <li>for a fixed path $\pi$, the optimal map $f$ (when $\mathcal{F}$ is the
Stiefel manifold) is obtained through Singular Value Decomposition.</li>
</ol>

<p>Interestingly, this optimization strategy where we alternate between time
series alignment, <em>i.e.</em> time correspondences between both time series, and
feature space transform optimization can be seen as a variant of the Iterative
Closest Point (ICP) method in image registration <a class="citation" href="#CHEN1992145">(Chen &amp; Medioni, 1992)</a>, in
which  nearest neighbors are replaced by matches resulting from DTW alignment.</p>

<p>The resulting algorithm is detailed in the following code:</p>

<p>```python tags=[“hide_input”]
import numpy</p>

<p>def path2mat(path):
    max0, max1 = path[-1]
    w_pi = numpy.zeros((max0 + 1, max1 + 1))
    for i, j in path:
        w_pi[i, j] = 1.
    return w_pi</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
```python
import scipy
from tslearn.utils import to_time_series
from tslearn.metrics import dtw_path

def dtw_gi(ts0, ts1, init_p=None, max_iter=20, verbose=False, use_bias=False):
    r"""Compute Dynamic Time Warping with Global Invariance (DTW-GI) similarity
    measure between (possibly multidimensional) time series and return it.

    Parameters
    ----------
    ts0: array of shape (sz0, d0)
        A time series.

    ts1: array of shape (sz1, d1)
        A time series.

    init_p : array of shape (d0, d1) (default: None)
        Initial p matrix for the Stiefel linear map. If None, identity matrix
        is used.

    max_iter : int (default: 20)
        Number of iterations for the iterative optimization algorithm.

    verbose: boolean (default: True)
        Whether information should be printed during optimization

    use_bias: boolean (default: False)
        If True, the feature space map is affine, otherwise it is linear.

    Returns
    -------
    w_pi
        Warping matrix (binary matrix of shape (sz0, sz1))

    p
        Stiefel matrix

    cost
        Similarity score
    """
    ts0_ = to_time_series(ts0, remove_nans=True)
    ts1_ = to_time_series(ts1, remove_nans=True)

    sz0, d0 = ts0_.shape
    sz1, d1 = ts1_.shape

    ts0_m = ts0_.mean(axis=0).reshape((-1, 1))
    ts1_m = ts1_.mean(axis=0).reshape((-1, 1))

    w_pi = numpy.zeros((sz0, sz1))
    if init_p is None:
        p = numpy.eye(d0, d1)
    else:
        p = init_p
    bias = numpy.zeros((d0, 1))

    # BCD loop
    for iter in range(1, max_iter + 1):
        w_pi_old = w_pi
        # Temporal alignment
        path, cost = dtw_path(ts0_, ts1_.dot(p.T) + bias.T)
        if verbose:
            print("Iteration {}: DTW cost: {:.3f}".format(iter, cost))
        w_pi = path2mat(path)
        if numpy.allclose(w_pi, w_pi_old):
            break
        # Feature space registration
        if use_bias:
            m = (ts0_.T - ts0_m).dot(w_pi).dot(ts1_ - ts1_m.T)
        else:
            m = (ts0_.T).dot(w_pi).dot(ts1_)
        u, sigma, vt = scipy.linalg.svd(m, full_matrices=False)
        p = u.dot(vt)
        if use_bias:
            bias = ts0_m - ts1_m.T.dot(p.T).T
    path, cost = dtw_path(ts0_, ts1_.dot(p.T) + bias.T)
    if verbose:
        print("After optimization: DTW cost: {:.3f}".format(cost))
    if use_bias:
        return w_pi, p, bias, cost
    else:
        return w_pi, p, cost
</code></pre></div></div>

<h2 id="results">Results</h2>

<p>We show that one can compute barycenters for this metric (using a similar
approach as the DTW Barycenter Averaging from <a class="citation" href="#PETITJEAN2011678">(Petitjean, Ketterlin, &amp; Gançarski, 2011)</a>),
even when time series to be averaged do not lie in the same ambient space:</p>

<p>```python tags=[“hide_input”]
%config InlineBackend.figure_format = ‘svg’
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D</p>

<p>plt.ion()</p>

<p>from sklearn.exceptions import ConvergenceWarning
from tslearn.utils import to_time_series, ts_size
from tslearn.barycenters import dtw_barycenter_averaging</p>

<p>def _set_weights(w, n):
    “"”Return w if it is a valid weight vector of size n, and a vector of n 1s
    otherwise.
    “””
    if w is None or len(w) != n:
        w = numpy.ones((n,))
    return w</p>

<p>def _init_avg(X, barycenter_size):
    if ts_size(X[0]) == barycenter_size:
        return numpy.nanmean(X, axis=0)
    else:
        X_avg = numpy.nanmean(X, axis=0)
        xnew = numpy.linspace(0, 1, barycenter_size)
        f = interp1d(numpy.linspace(0, 1, X_avg.shape[0]), X_avg,
                     kind=”linear”, axis=0)
        return f(xnew)</p>

<p>def _mm_assignment(X, barycenter, weights, list_init_p=None,
                   metric_params=None):
    “"”Computes item assignement based on DTW alignments and return cost as a
    bonus.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Parameters
----------
X : numpy.array of shape (n, sz, d)
    Time-series to be averaged

barycenter : numpy.array of shape (barycenter_size, d)
    Barycenter as computed at the current step of the algorithm.

weights: array
    Weights of each X[i]. Must be the same size as len(X).

list_init_p: list of arrays of shape (d, d)
    Initial P matrices

metric_params: dict or None (default: None)
    Key-value parameters for f_dtw

Returns
-------
list_W_pi
    List of warping matrices

list_p
    List of mapping matrices

float
    Current alignment cost
"""
if metric_params is None:
    metric_params = {}
n = len(X)
if list_init_p is None:
    list_init_p = [numpy.eye(Xi.shape[1], barycenter.shape[1]).T
                   for Xi in X]
cost = 0.
list_w_pi = []
list_p = []
list_bias = []
for i in range(n):
    w_pi, p_i, bias_i, dist_i = dtw_gi(barycenter, X[i],
                                       init_p=list_init_p[i],
                                       use_bias=True,
                                       **metric_params)
    cost += dist_i ** 2 * weights[i]
    list_w_pi.append(w_pi)
    list_p.append(p_i)
    list_bias.append(bias_i)
cost /= weights.sum()
return list_w_pi, list_p, list_bias, cost
</code></pre></div></div>

<p>def _subgradient_valence_warping(list_w_pi, weights):
    “"”Compute Valence and Warping matrices from paths.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Valence matrices are denoted :math:`V^{(k)}` and Warping matrices are
:math:`W^{(k)}` in [1]_.

This function returns a list of :math:`V^{(k)}` diagonals (as a vector)
and a list of :math:`W^{(k)}` matrices.

Parameters
----------
list_w_pi : list of arrays of shape (sz_bar, sz_i)
    List of warping matrices

weights: array
    Weights of each X[i]. Must be the same size as len(X).

Returns
-------
list of numpy.array of shape (barycenter_size, )
    list of weighted :math:`V^{(k)}` diagonals (as a vector)

list of numpy.array of shape (barycenter_size, sz_k)
    list of weighted :math:`W^{(k)}` matrices

References
----------

.. [1] D. Schultz and B. Jain. Nonsmooth Analysis and Subgradient Methods
   for Averaging in Dynamic Time Warping Spaces.
   Pattern Recognition, 74, 340-358.
"""
list_v_k = []
list_w_k = []
for k, w_pi in enumerate(list_w_pi):
    list_w_k.append(w_pi * weights[k])
    list_v_k.append(w_pi.sum(axis=1) * weights[k])
return list_v_k, list_w_k
</code></pre></div></div>

<p>def _mm_valence_warping(list_w_pi, weights):
    “"”Compute Valence and Warping matrices from paths.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Valence matrices are denoted :math:`V^{(k)}` and Warping matrices are
:math:`W^{(k)}` in [1]_.

This function returns the sum of :math:`V^{(k)}` diagonals (as a vector)
and a list of :math:`W^{(k)}` matrices.

Parameters
----------
list_w_pi : list of arrays of shape (sz_bar, sz_i)
    list of Warping matrices

barycenter_size : int
    Size of the barycenter to generate.

weights: array
    Weights of each X[i]. Must be the same size as len(X).

Returns
-------
numpy.array of shape (barycenter_size, )
    sum of weighted :math:`V^{(k)}` diagonals (as a vector)

list of numpy.array of shape (barycenter_size, sz_k)
    list of weighted :math:`W^{(k)}` matrices

References
----------

.. [1] D. Schultz and B. Jain. Nonsmooth Analysis and Subgradient Methods
   for Averaging in Dynamic Time Warping Spaces.
   Pattern Recognition, 74, 340-358.
"""
list_v_k, list_w_k = _subgradient_valence_warping(
    list_w_pi=list_w_pi,
    weights=weights)
diag_sum_v_k = numpy.zeros(list_v_k[0].shape)
for v_k in list_v_k:
    diag_sum_v_k += v_k
return diag_sum_v_k, list_w_k
</code></pre></div></div>

<p>def <em>mm_update_barycenter(X, diag_sum_v_k, list_w_k):
    “"”Update barycenters using the formula from Algorithm 2 in [1]</em>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Parameters
----------
X : numpy.array of shape (n, sz, d)
    Time-series to be averaged

diag_sum_v_k : numpy.array of shape (barycenter_size, )
    sum of weighted :math:`V^{(k)}` diagonals (as a vector)

list_w_k : list of numpy.array of shape (barycenter_size, sz_k)
    list of weighted :math:`W^{(k)}` matrices

Returns
-------
numpy.array of shape (barycenter_size, d)
    Updated barycenter

References
----------

.. [1] D. Schultz and B. Jain. Nonsmooth Analysis and Subgradient Methods
   for Averaging in Dynamic Time Warping Spaces.
   Pattern Recognition, 74, 340-358.
"""
d = X[0].shape[-1]
barycenter_size = diag_sum_v_k.shape[0]
sum_w_x = numpy.zeros((barycenter_size, d))
for k, (w_k, x_k) in enumerate(zip(list_w_k, X)):
    sum_w_x += w_k.dot(x_k[:ts_size(x_k)])
barycenter = numpy.diag(1. / diag_sum_v_k).dot(sum_w_x)
return barycenter
</code></pre></div></div>

<p>def dtw_gi_barycenter_averaging(X, barycenter_size=None, init_barycenter=None,
                                max_iter=30, tol=1e-5, weights=None,
                                metric_params=None, keep_p_matrices=False,
                                verbose=False):
    “"”DTW-GI Barycenter Averaging (DBA) method estimated through
    Expectation-Maximization algorithm.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DBA was originally presented in [1]_.
This implementation is based on a idea from [2]_ (Majorize-Minimize Mean
Algorithm).

Here, the transform is of the form x -&gt; Ax + b where A lies on the Stiefel
manifold.

Parameters
----------
X : array-like, shape=(n_ts, sz, d)
    Time series dataset.

barycenter_size : int or None (default: None)
    Size of the barycenter to generate. If None, the size of the barycenter
    is that of the data provided at fit
    time or that of the initial barycenter if specified.

init_barycenter : array or None (default: None)
    Initial barycenter to start from for the optimization process.

max_iter : int (default: 30)
    Number of iterations of the Expectation-Maximization optimization
    procedure.

tol : float (default: 1e-5)
    Tolerance to use for early stopping: if the decrease in cost is lower
    than this value, the
    Expectation-Maximization procedure stops.

weights: None or array
    Weights of each X[i]. Must be the same size as len(X).
    If None, uniform weights are used.

metric_params: dict or None (default: None)
    DTW constraint parameters to be used.
    See :ref:`tslearn.metrics.dtw_path &lt;fun-tslearn.metrics.dtw_path&gt;` for
    a list of accepted parameters
    If None, no constraint is used for DTW computations.

keep_p_matrices: bool (default: False)
    Whether P matrices from previous iteration should be used to initialize
    P matrices for the current iteration

verbose : boolean (default: False)
    Whether to print information about the cost at each iteration or not.

Returns
-------
numpy.array of shape (barycenter_size, d) or (sz, d) if barycenter_size \
        is None
    DBA barycenter of the provided time series dataset.

float
    Corresponding cost (weighted sum of alignment costs)

References
----------
.. [1] F. Petitjean, A. Ketterlin &amp; P. Gancarski. A global averaging method
   for dynamic time warping, with applications to clustering. Pattern
   Recognition, Elsevier, 2011, Vol. 44, Num. 3, pp. 678-693

.. [2] D. Schultz and B. Jain. Nonsmooth Analysis and Subgradient Methods
   for Averaging in Dynamic Time Warping Spaces.
   Pattern Recognition, 74, 340-358.
"""
X_ = [to_time_series(Xi, remove_nans=True) for Xi in X]
if barycenter_size is None:
    barycenter_size = ts_size(X_[0])
weights = _set_weights(weights, len(X_))
if init_barycenter is None:
    barycenter = _init_avg(X_, barycenter_size)
else:
    barycenter = init_barycenter
cost_prev, cost = numpy.inf, numpy.inf
list_p = [numpy.eye(Xi.shape[1], barycenter.shape[1]).T for Xi in X_]
for it in range(max_iter):
    if not keep_p_matrices:
        list_p = None
    list_w_pi, list_p, list_bias, cost = _mm_assignment(
        X_,
        barycenter,
        weights,
        list_init_p=list_p,
        metric_params=metric_params
    )
    diag_sum_v_k, list_w_k = _mm_valence_warping(list_w_pi, weights)
    if verbose:
        print("[DBA] epoch %d, cost: %.3f" % (it + 1, cost))
    rotated_x = [numpy.empty(Xi.shape) for Xi in X_]
    for i in range(len(X_)):
        rotated_x[i] = X_[i].dot(list_p[i].T) + list_bias[i].T
    barycenter = _mm_update_barycenter(rotated_x, diag_sum_v_k, list_w_k)
    if abs(cost_prev - cost) &lt; tol:
        break
    elif cost_prev &lt; cost:
        warnings.warn("DBA loss is increasing while it should not be. "
                      "Stopping optimization.", ConvergenceWarning)
        break
    else:
        cost_prev = cost
return barycenter, cost
</code></pre></div></div>

<h1 id="a-list-of-data-generation--plotting-utils">A list of data generation / plotting utils</h1>

<p>def has_3d(dataset):
    for sample in dataset:
        if sample.shape[-1] == 3:
            return True
    return False</p>

<p>def plot_trajectory(ts, ax, plot_3d=False, color_code=None, alpha=1.):
    if color_code is not None:
        colors = [color_code] * len(ts)
    else:
        colors = plt.cm.jet(numpy.linspace(0, 1, len(ts)))
    for i in range(len(ts) - 1):
        if plot_3d:
            ax.plot(ts[i:i+2, 0], ts[i:i+2, 1], ts[i:i+2, 2],
                    marker=’o’, c=colors[i], alpha=alpha)
        else:
            ax.plot(ts[i:i+2, 0], ts[i:i+2, 1],
                    marker=’o’, c=colors[i], alpha=alpha)</p>

<p>def get_rot2d(theta):
    return numpy.array(
        [[numpy.cos(theta), -numpy.sin(theta)],
         [numpy.sin(theta), numpy.cos(theta)]]
    )</p>

<p>def get_rot3d(alpha, beta, gamma):
    R_alpha = numpy.array(
        [[1., 0., 0.],
         [0., numpy.cos(alpha), -numpy.sin(alpha)],
         [0., numpy.sin(alpha), numpy.cos(alpha)]]
    )
    R_beta = numpy.array(
        [[numpy.cos(beta), 0., numpy.sin(beta)],
         [0., 1., 0.],
         [-numpy.sin(beta), 0., numpy.cos(beta)]]
    )
    R_gamma = numpy.array(
        [[numpy.cos(gamma), -numpy.sin(gamma), 0.],
         [numpy.sin(gamma), numpy.cos(gamma), 0.],
         [0., 0., 1.]]
    )
    return R_alpha.dot(R_beta).dot(R_gamma)</p>

<p>def make_one_spiral(sz, noise=.5):
    uniform_in_01 = numpy.random.rand(sz, 1)
    non_uniform_in_01 = numpy.power(uniform_in_01, 4)
    n = numpy.sqrt(non_uniform_in_01) * 780 * (2 * numpy.pi) / 360
    n = numpy.sort(n.reshape((-1, ))).reshape((-1, 1))
    d1x = -numpy.cos(n) * n + numpy.random.rand(sz, 1) * noise
    d1y = numpy.sin(n) * n + numpy.random.rand(sz, 1) * noise
    arr = numpy.array(numpy.hstack((d1x, d1y)))
    return arr / numpy.max(n)</p>

<p>def make_spirals(n, sz, noise=.5, shift=False, some_3d=False):
    dataset = []
    for i in range(n):
        if some_3d and i % 2 == 0:
            spiral = make_one_spiral(sz=sz, noise=0.)
            spiral = numpy.hstack((spiral, noise * numpy.random.randn(sz, 1)))
            alpha = (numpy.random.rand(1)[0] - .5) * numpy.pi / 2
            beta = (numpy.random.rand(1)[0] - .5) * numpy.pi / 2
            gamma = (numpy.random.rand(1)[0] - .5) * numpy.pi / 2
            spiral = numpy.dot(spiral, get_rot3d(alpha, beta, gamma))
            if shift:
                spiral += numpy.random.rand(3) * 3
        else:
            spiral = make_one_spiral(sz=sz, noise=noise)
            theta = numpy.random.rand(1)[0] * 2 * numpy.pi
            spiral = numpy.dot(spiral, get_rot2d(theta))
            if shift:
                spiral += numpy.random.rand(2) * 3
        dataset.append(spiral)
    return dataset</p>

<p>def make_one_folium(sz, a=1., noise=.1, resample_fun=None):
    theta = numpy.linspace(0, 1, sz)
    if resample_fun is not None:
        theta = resample_fun(theta)
    theta -= .5
    theta *= .9 * numpy.pi
    theta = theta.reshape((-1, 1))
    r = a / 2 * (4 * numpy.cos(theta) - 1. / numpy.cos(theta))
    x = r * numpy.cos(theta) + numpy.random.rand(sz, 1) * noise
    y = r * numpy.sin(theta) + numpy.random.rand(sz, 1) * noise
    return numpy.array(numpy.hstack((x, y)))</p>

<p>def make_folia(n, sz, noise=.1, shift=False, some_3d=False):
    if some_3d:
        raise NotImplementedError
    dataset = []
    for _ in range(n):
        spiral = make_one_folium(sz=sz, a=1., noise=noise)
        theta = numpy.random.rand(1)[0] * 2 * numpy.pi
        spiral = numpy.dot(spiral, get_rot2d(theta))
        if shift:
            spiral += numpy.random.rand(2) * 3
        dataset.append(spiral)
    return dataset</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
```python tags=["hide_input"]
numpy.random.seed(0)

# Parameters of the experiment
n_spirals = 3
n_spirals_shown = 3
sz = 50
sz_barycenter = 25
d_barycenter = 2

# Datasets
list_dataset_generators = [
    lambda n, sz: make_folia(n, sz=sz, shift=False, some_3d=False),
    lambda n, sz: make_spirals(n, sz=sz, noise=.01, shift=False, some_3d=True)
]

# Methods
list_barycenter_fun = [
    lambda dataset, sz, b: dtw_barycenter_averaging(dataset,
                                                    init_barycenter=b,
                                                    barycenter_size=sz,
                                                    max_iter=200),
    lambda dataset, sz, b: dtw_gi_barycenter_averaging(dataset,
                                                       init_barycenter=b,
                                                       barycenter_size=sz,
                                                       verbose=False,
                                                       max_iter=1000,
                                                       keep_p_matrices=True,
                                                       metric_params={
                                                           "max_iter": 1000
                                                       })[0]
]
list_method_names = ["DTW", "DTW-GI"]

angles_visu = [90, numpy.nan, -120]

fig = plt.figure(figsize=(.67 * (3 * n_spirals_shown + len(list_barycenter_fun)),
                          2. * len(list_dataset_generators)))
for idx_dataset, dataset_fun in enumerate(list_dataset_generators):
    spirals = dataset_fun(n_spirals, sz)

    # Plot sample spirals
    for i in range(n_spirals_shown):
        if spirals[i].shape[-1] == 3:
            ax = fig.add_subplot(len(list_dataset_generators),
                                 n_spirals_shown + len(list_barycenter_fun),
                                 (n_spirals_shown + len(list_barycenter_fun))
                                 * idx_dataset + i + 1, projection="3d")
            plot_trajectory(spirals[i], ax=ax, plot_3d=True)
            ax.set_zticks([])
            ax.view_init(elev=20., azim=angles_visu[i])
        else:
            ax = fig.add_subplot(len(list_dataset_generators),
                                 n_spirals_shown + len(list_barycenter_fun),
                                 (n_spirals_shown + len(list_barycenter_fun))
                                 * idx_dataset + i + 1)
            plot_trajectory(spirals[i], ax=ax)
        ax.set_xticks([])
        ax.set_yticks([])
        if idx_dataset == 0:
            ax.set_title("Sample {}".format(i + 1))

    # Plot barycenters
    for i, (barycenter_fun, title) in enumerate(zip(list_barycenter_fun,
                                                    list_method_names)):
        init_b = numpy.random.randn(sz_barycenter, d_barycenter)
        if title == "DTW" and has_3d(spirals):
            continue
        barycenter = barycenter_fun(spirals, sz_barycenter, init_b)
        ax = plt.subplot(len(list_dataset_generators),
                         n_spirals_shown + len(list_barycenter_fun),
                         (n_spirals_shown + len(list_barycenter_fun))
                         * idx_dataset +
                         n_spirals_shown + i + 1)
        plot_trajectory(barycenter, ax=ax)
        ax.set_xticks([])
        ax.set_yticks([])
        if idx_dataset == 0:
            ax.set_title(title)
</code></pre></div></div>

<p>We also introduce soft counterparts following the definition of softDTW from
<a class="citation" href="#cuturi2017soft">(Cuturi &amp; Blondel, 2017)</a>.</p>

<p>We validate the utility of this new metric on real world
datasets on the tasks of human motion prediction (where motion is captured under
different points of view) and cover song identification (where song similarity
is defined up to a key transposition).
In both these settings, we observe that joint optimization on feature space
transformation and temporal alignment improves over standard techniques that
consider these as two independent steps.</p>

<h2 id="references">References</h2>

<ol class="bibliography"><li><span id="vayer2020time">Vayer, T., Chapel, L., Courty, N., Flamary, R., Soullard, Y., &amp; Tavenard, R. (2020). Time Series Alignment with Global Invariances.</span></li>
<li><span id="CHEN1992145">Chen, Y., &amp; Medioni, G. (1992). Object modelling by registration of multiple range images. <i>Image and Vision Computing</i>, <i>10</i>(3), 145–155.</span></li>
<li><span id="PETITJEAN2011678">Petitjean, F., Ketterlin, A., &amp; Gançarski, P. (2011). A global averaging method for dynamic time warping, with applications to clustering. <i>Elsevier Pattern Recognition</i>, <i>44</i>(3), 678–693.</span></li>
<li><span id="cuturi2017soft">Cuturi, M., &amp; Blondel, M. (2017). Soft-DTW: a differentiable loss function for time-series. In <i>Proceedings of the International Conference on Machine Learning</i> (pp. 894–903).</span></li></ol>

            </div>
            <div class="c-textbook__footer" id="textbook_footer">
              
<nav class="c-page__nav">
  

  
</nav>

              <footer>
  <p class="footer"></p>
</footer>

            </div>

        </div>
      </main>
    </div>
  </body>
</html>
