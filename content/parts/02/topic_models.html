<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,minimum-scale=1">

  <title>Machine Learning for Time Series</title>
  <meta name="description" content="# Temporal Topic ModelsTopic models are mixture models that can deal with documents represented asbags of features (BoF) and that can extract latent topics (...">

  <link rel="canonical" href="https://rtavenar.github.io/hdr/content/parts/02/topic_models.html">
  <link rel="alternate" type="application/rss+xml" title="Machine Learning for Time Series" href="https://rtavenar.github.io/hdr/feed.xml">

  <meta property="og:url"         content="https://rtavenar.github.io/hdr/content/parts/02/topic_models.html" />
<meta property="og:type"        content="article" />
<meta property="og:title"       content="Machine Learning for Time Series" />
<meta property="og:description" content="# Temporal Topic ModelsTopic models are mixture models that can deal with documents represented asbags of features (BoF) and that can extract latent topics (..." />
<meta property="og:image"       content="https://rtavenar.github.io/hdr/false" />

<meta name="twitter:card" content="summary">


  <script type="application/ld+json">
  {
  "@context": "http://schema.org",
  "@type": "NewsArticle",
  "mainEntityOfPage": "https://rtavenar.github.io/hdr/content/parts/02/topic_models.html",
  "headline": "Machine Learning for Time Series",
  "datePublished": "2020-12-17T16:45:23+01:00",
  "dateModified": "2020-12-17T16:45:23+01:00",
  "description": "# Temporal Topic ModelsTopic models are mixture models that can deal with documents represented asbags of features (BoF) and that can extract latent topics (...",
  "author": {
    "@type": "Person",
    "name": "Romain Tavenard"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Data 100 at UC Berkeley",
    "logo": {
      "@type": "ImageObject",
      "url": "https://rtavenar.github.io/hdr",
      "width": 60,
      "height": 60
    }
  },
  "image": {
    "@type": "ImageObject",
    "url": "https://rtavenar.github.io/hdr",
    "height": 60,
    "width": 60
  }
}

  </script>
  <link rel="stylesheet" href="/hdr/assets/css/styles.css">

  <!-- <link rel="manifest" href="/manifest.json"> -->
  <!-- <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#efae0a"> -->
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-TileImage" content="/mstile-144x144.png">
  <meta name="theme-color" content="#233947">

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/x-icon" href="/hdr/images/logo/favicon.ico">

  <!-- MathJax Config -->
  <!-- Allow inline math using $ and automatically break long math lines -->
<!-- (mostly) copied from nbconvert configuration -->
<!-- https://github.com/jupyter/nbconvert/blob/master/nbconvert/templates/html/mathjax.tpl -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
        processEnvironments: true
    },
    // Center justify equations in code and markdown cells. Elsewhere
    // we use CSS to left justify single line equations in code cells.
    displayAlign: 'center',
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}},
        linebreaks: { automatic: true },
    },
    
    // Number LaTeX-style equations
    "TeX": {
        equationNumbers: {
          autoNumber: "all"
        }
    }
    
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML' async></script>


  <!-- DOM updating function -->
  <script src="/hdr/assets/js/page/dom-update.js"></script>

  <!-- Selectors for elements on the page -->
  <script src="/hdr/assets/js/page/documentSelectors.js"></script>

  <!-- Define some javascript variables that will be useful in other javascript -->
  <script>
    const site_basename = '/hdr';
  </script>

  <!-- Add AnchorJS to let headers be linked -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.0/anchor.min.js" async></script>
  <script src="/hdr/assets/js/page/anchors.js" async></script>

  <!-- Include Turbolinks to make page loads fast -->
  <!-- https://github.com/turbolinks/turbolinks -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/turbolinks/5.2.0/turbolinks.js" async></script>
  <meta name="turbolinks-cache-control" content="no-cache">

  <!-- Load nbinteract for widgets -->
  

  <!-- Load Thebelab for interactive widgets -->
  <!-- Include Thebelab for interactive code if it's enabled -->



  <!-- Load the auto-generating TOC (non-async otherwise the TOC won't load w/ turbolinks) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.8.1/tocbot.min.js" async></script>
  <script src="/hdr/assets/js/page/tocbot.js"></script>

  <!-- Google analytics -->
  


  <!-- Clipboard copy button -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script>

  <!-- Load custom website scripts -->
  <script src="/hdr/assets/js/scripts.js" async></script>

  <!-- Load custom user CSS and JS  -->
  <script src="/hdr/assets/custom/custom.js" async></script>
  <link rel="stylesheet" href="/hdr/assets/custom/custom.css">

  <!-- Update interact links w/ REST param, is defined in includes so we can use templates -->
  

  <!-- Lunr search code - will only be executed on the /search page -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js" async></script>
  <script>var initQuery = function() {
  // See if we have a search box
  var searchInput = document.querySelector('input#lunr_search');
  if (searchInput === null) {
    return;
  }

  // Function to parse our lunr cache
  var idx = lunr(function () {
    this.field('title')
    this.field('excerpt')
    this.field('categories')
    this.field('tags')
    this.ref('id')

    this.pipeline.remove(lunr.trimmer)

    for (var item in store) {
      this.add({
        title: store[item].title,
        excerpt: store[item].excerpt,
        categories: store[item].categories,
        tags: store[item].tags,
        id: item
      })
    }
  });

  // Run search upon keyup
  searchInput.addEventListener('keyup', function () {
    var resultdiv = document.querySelector('#results');
    var query = document.querySelector("input#lunr_search").value.toLowerCase();
    var result =
      idx.query(function (q) {
        query.split(lunr.tokenizer.separator).forEach(function (term) {
          q.term(term, { boost: 100 })
          if(query.lastIndexOf(" ") != query.length-1){
            q.term(term, {  usePipeline: false, wildcard: lunr.Query.wildcard.TRAILING, boost: 10 })
          }
          if (term != ""){
            q.term(term, {  usePipeline: false, editDistance: 1, boost: 1 })
          }
        })
      });

      // Empty the results div
      while (resultdiv.firstChild) {
        resultdiv.removeChild(resultdiv.firstChild);
      }

    resultdiv.insertAdjacentHTML('afterbegin', '<p class="results__found">'+result.length+' Result(s) found</p>');
    for (var item in result) {
      var ref = result[item].ref;
      if(store[ref].teaser){
        var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<div class="archive__item-teaser">'+
                '<img src="'+store[ref].teaser+'" alt="">'+
              '</div>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      else{
    	  var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      resultdiv.insertAdjacentHTML('beforeend', searchitem);
    }
  });
};

initFunction(initQuery);
</script>

  <!-- Load JS that depends on site variables -->
  <script src="/hdr/assets/js/page/copy-button.js" async></script>

  <!-- Hide cell code -->
  <script src="/hdr/assets/js/page/hide-cell.js" async></script>

  <!-- Printing the screen -->
  <!-- Include nbinteract for interactive widgets -->
<script src="https://printjs-4de6.kxcdn.com/print.min.js" async></script>
<script>
printContent = () => {
    // MathJax displays a second version of any math for assistive devices etc.
    // This prevents double-rendering in the PDF output.
    var ignoreAssistList = [];
    assistives = document.querySelectorAll('.MathJax_Display span.MJX_Assistive_MathML').forEach((element, index) => {
        var thisId = 'MathJax-assistive-' + index.toString();
        element.setAttribute('id', thisId);
        ignoreAssistList.push(thisId)
    });

    // Print the actual content object
    printJS({
        printable: 'textbook_content',
        type: 'html',
        css: "/hdr/assets/css/styles.css",
        style: "#textbook_content {padding-top: 40px};",
        scanStyles: false,
        targetStyles: ["*"],
        ignoreElements: ignoreAssistList,
        documentTitle: "Made with Jupyter Book"
    })
};

initPrint = () => {
    document.querySelector('#interact-button-print').addEventListener('click', printContent)
}

initFunction(initPrint)
</script>

</head>

  <body>
    <!-- Include the ThebeLab config so it gets reloaded on each page -->
    <script type="text/x-thebe-config">{
    requestKernel: true,
    binderOptions: {
    repo: "rtavenar/hdr",
    ref: "gh-pages",
    },
    codeMirrorConfig: {
    theme: "abcdef",
    mode: "python"
    },
    kernelOptions: {
    kernelName: "python3",
    path: ""
    }
}
</script>

    <!-- .js-show-sidebar shows sidebar by default -->
    <div id="js-textbook" class="c-textbook js-show-sidebar">
      



<nav id="js-sidebar" class="c-textbook__sidebar">
  
  <h2 class="c-sidebar__title">Machine Learning for Time Series</h2>
  <ul class="c-sidebar__chapters">
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/parts/about">
        <a class="c-sidebar__entry"
          href="/hdr/parts/about.html"
        >
          
          Preamble
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/parts/intro">
        <a class="c-sidebar__entry"
          href="/hdr/parts/intro.html"
        >
          
          Introduction
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/parts/01_metrics">
        <a class="c-sidebar__entry"
          href="/hdr/parts/01_metrics.html"
        >
          
            1.
          
          Defining Adequate Metrics for Structured Data
        </a>
      </li>

      
      

      

      
      

      
        

        

        <ul class="c-sidebar__sections">
          
            
            

            
            
            
            

            <li class="c-sidebar__section" data-url="/parts/01/temporal_kernel">
              <a class="c-sidebar__entry"
                href="/hdr/parts/01/temporal_kernel.html"
              >
                
                  1.1
                
                A Temporal Kernel for Time Series
              </a>
            </li>
            
            
          
            
            

            
            
            
            

            <li class="c-sidebar__section" data-url="/parts/01/dtw">
              <a class="c-sidebar__entry"
                href="/hdr/parts/01/dtw.html"
              >
                
                  1.2
                
                Dynamic Time Warping
              </a>
            </li>
            
              
              <ul class='c-sidebar__subsections'>
              
                
                
                
                
                <li class="c-sidebar__subsection" data-url="/parts/01/dtw/dtw_warping_length">
                  <a class="c-sidebar__entry"
                    href="/hdr/parts/01/dtw/dtw_warping_length.html"
                  >
                    
                      1.2.1
                      
                    
                    Constrained Dynamic Time Warping
                  </a>
                </li>
              
                
                
                
                
                <li class="c-sidebar__subsection" data-url="/parts/01/dtw/dtw_da">
                  <a class="c-sidebar__entry"
                    href="/hdr/parts/01/dtw/dtw_da.html"
                  >
                    
                      1.2.2
                      
                    
                    DTW Alignment as an Adaptive Resampling Strategy
                  </a>
                </li>
              
                
                
                
                
                <li class="c-sidebar__subsection" data-url="/parts/01/dtw/dtw_gi">
                  <a class="c-sidebar__entry"
                    href="/hdr/parts/01/dtw/dtw_gi.html"
                  >
                    
                      1.2.3
                      
                    
                    DTW with Global Invariances
                  </a>
                </li>
              
              </ul>
            
            
          
            
            

            
            
            
            

            <li class="c-sidebar__section" data-url="/parts/01/ot">
              <a class="c-sidebar__entry"
                href="/hdr/parts/01/ot.html"
              >
                
                  1.3
                
                Optimal Transport for Structured Data
              </a>
            </li>
            
            
          
        </ul>
      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/parts/02_representations">
        <a class="c-sidebar__entry"
          href="/hdr/parts/02_representations.html"
        >
          
            2.
          
          Learning Sensible Representations for Time Series
        </a>
      </li>

      
      

      

      
      

      
        

        

        <ul class="c-sidebar__sections">
          
            
            

            
            
            
            

            <li class="c-sidebar__section" data-url="/parts/02/topic_models">
              <a class="c-sidebar__entry"
                href="/hdr/parts/02/topic_models.html"
              >
                
                  2.1
                
                Temporal Topic Models
              </a>
            </li>
            
            
          
            
            

            
            
            
            

            <li class="c-sidebar__section" data-url="/parts/02/shapelets_cnn">
              <a class="c-sidebar__entry"
                href="/hdr/parts/02/shapelets_cnn.html"
              >
                
                  2.2
                
                Shapelet-based Representations and Convolutional Models
              </a>
            </li>
            
            
          
            
            

            
            
            
            

            <li class="c-sidebar__section" data-url="/parts/02/early">
              <a class="c-sidebar__entry"
                href="/hdr/parts/02/early.html"
              >
                
                  2.3
                
                Early Classification of Time Series
              </a>
            </li>
            
            
          
        </ul>
      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/parts/conclu">
        <a class="c-sidebar__entry"
          href="/hdr/parts/conclu.html"
        >
          
          Perspectives
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      
        <li class="c-sidebar__divider"></li>
        
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/contributing">
        <a class="c-sidebar__entry"
          href="/hdr/contributing.html"
        >
          
          Feedback welcome
        </a>
      </li>

      
      

      

      
      

      

      
    
  </ul>
  <p class="sidebar_footer">Romain Tavenard's HDR thesis.<br />Powered by <a href='https://jupyterbook.org'>Jupyter Book</a>.</p>
</nav>

      
      <div class="c-topbar" id="top-navbar">
  <!-- We show the sidebar by default so we use .is-active -->
  <div class="c-topbar__buttons">
    <button
      id="js-sidebar-toggle"
      class="hamburger hamburger--arrowalt is-active"
    >
      <span class="hamburger-box">
        <span class="hamburger-inner"></span>
      </span>
    </button>
    <div class="buttons">
<div class="download-buttons-dropdown">
    <button id="dropdown-button-trigger" class="interact-button"><img src="/hdr/assets/images/download-solid.svg" alt="Download" /></button>
    <div class="download-buttons">
        
        <a id="interact-button-print"><button id="interact-button-download" class="interact-button">.pdf</button></a>
    </div>
</div>


</div>

  </div>
  <!-- Empty sidebar placeholder that we'll auto-fill with javascript -->
  <aside class="sidebar__right">
    <header><h4 class="nav__title"><img src="/hdr/assets/images/list-solid.svg" alt="Search" />   On this page</h4></header>
    <nav class="onthispage">
    </nav>
  </aside>
  <a href="/hdr/search.html" class="topbar-right-button" id="search-button">
    <img src="/hdr/assets/images/search-solid.svg" alt="Search" />
  </a>
</div>

      <main class="c-textbook__page" tabindex="-1">
            <div class="c-textbook__content" id="textbook_content">
              <h1 id="temporal-topic-models">Temporal Topic Models</h1>

<p>Topic models are mixture models that can deal with documents represented as
bags of features (BoF) and that can extract latent topics (a topic being a
distribution
over features) from a corpus of documents.
For these methods, time series are hence seen as bags of timestamped features.
In the methods presented here, the temporal dimension is either
<a href="#Supervised-Hierarchical-Dirichlet-Latent-Semantic-Motifs">included in the BoF representation</a>
or added
<a href="#Two-step-Inference-for-Sequences-of-Ornstein-Uhlenbeck-Processes">in a refinement step</a>.</p>

<h2 id="supervised-hierarchical-dirichlet-latent-semantic-motifs">Supervised Hierarchical Dirichlet Latent Semantic Motifs</h2>

<p>In this work, we build upon the Hierarchical Dirichlet Latent Semantic Motifs
(HDLSM) topic model that was first introduced in <a class="citation" href="#EmonetCVPR2011">(Emonet, Varadarajan, &amp; Odobez, 2011)</a>.
This generative model relies on the extraction of motifs that encapsulate the
temporal information of the data.
It is able to automatically discover both the underlying number of motifs
needed to
model a given set of documents and the number and localization of motif
occurrences in each document, as shown in the following Figure:</p>

<p><img src="../../images/hdlsm.svg" alt="half-width" /></p>

<p>The HDLSM model takes as input a set of quantized time series (aka temporal
documents).
More specifically, a time series is represented as a contingency table that
informs, for
each pair $(w, t)$, whether word (or a quantized feature) $w$ was
present in the time series at time index $t$ (in fact, it can also account for
the <em>amount</em> of presence of word $w$ at time $t$).</p>

<p>HDLSM is a generative model. Its generative process can be described as
follows:</p>

<ol>
  <li>Generate a list of motifs, each motif $k$ being a 2D probability map
indicating how likely it is that word $w$ occurs at relative time $t_r$ after
the beginning of the motif.</li>
  <li>For each document $j$, generate a list of occurrences, each occurrence having
a starting time $t_o$ and an associated motif $k$.</li>
  <li>For each observation $i$ in document $j$:
    <ul>
      <li>Draw an occurrence from the list,</li>
      <li>Draw a pair $(w, t_r)$ from the associated motif,</li>
      <li>Generate the observation of word $w$ at time $t = t_o + t_r$.</li>
    </ul>
  </li>
</ol>

<p>As stated above, motifs are represented as probabilistic maps.
Each map is drawn from a Dirichlet distribution.
This model makes intensive use of Dirichlet Processes (DP) to model the
possibly infinite number of motifs and occurrences.</p>

<p>To learn the parameters of the model, Gibbs sampling is used, in which it
is sufficient to re-sample motif assignments for both observations and
occurrences as well as occurrence starting times.
Other variables are either integrated out or deduced, when a deterministic
relation holds.</p>

<p>Our supervised variant relies on the same generative process except that an
extra component is added that maps motifs (denoted $z$)
to classes ($y$) in a supervised learning
context.
Therefore, this mapping needs to be learned and, once the model is trained,
classifying a new instance $\mathbf{x}$ consists in
(i) extracting motif probabilities $P(z | \mathbf{x})$ and
(ii) deriving class probabilities as:</p>

<p>\begin{equation}
    P(y | \mathbf{x}) = \sum_z P(y | z) P(z | \mathbf{x})
\end{equation}</p>

<p>We have used this model in the context of action recognition in videos
<a class="citation" href="#tavenard:hal-00872048">(Tavenard, Emonet, &amp; Odobez, 2013)</a>.
Here, our <em>words</em> are quantized spatio-temporal features and each time series
is the encoding of a video in which a single action is performed.
In this context, we show that our
model outperforms standard competitors that operate on the same quantized
features.</p>

<h2 id="two-step-inference-for-sequences-of-ornstein-uhlenbeck-processes">Two-step Inference for Sequences of Ornstein Uhlenbeck Processes</h2>

<!-- #region {"tags": ["popout"]} -->
<p><strong>Note.</strong> This work was part of Pierre Gloaguen’s postdoc.
This is joint work with Laetitia Chapel and Chloé Friguet.
<!-- #endregion --></p>

<p>More recently, I have been involved in a project related to the surveillance of
the maritime traffic.
In this context, a major challenge
is the automatic identification of traffic flows from a set of observed
trajectories, in order to derive good management measures or to detect abnormal
or illegal behaviors for example.</p>

<p>The model we have proposed in this context differs from the one described above
in several aspects:</p>

<ul>
  <li>We are not in a supervised setting, we have no labelled data at our disposal
and our goal will rather be to extract meaningful trajectory clusters;</li>
  <li>We are not looking for motifs to be localized in time series (with
a possible overlap between motifs, as in the method described above) but rather
in the segmentation of trajectories into homogeneous <em>movement modes</em>;</li>
  <li>Each movement mode is described using a continuous time model;</li>
  <li>In order to scale to larger datasets, stochastic variational inference is used
(in place of Gibbs sampling) for inference.</li>
</ul>

<h3 id="motivating-use-case">Motivating Use Case</h3>

<p>The monitoring of maritime traffic relies on several sources of data, in a
rising context of maritime big data <a class="citation" href="#garnier2016exploiting">(Garnier &amp; Napoli, 2016)</a>.
Among these sources lies the Automatic Identification System (AIS), which
automatically collects messages from vessels around the world, at a high
frequency.
AIS data basically consist of GPS-like data, together with the instantaneous
speed and heading, and some vessel specific static information.
These data are characterized by their diversity as they (1) are collected at
different frequencies (2) have different lengths (3) are not necessarily
regularly sampled (4) represent very different behaviors, (5) share common
trends or similar subparts (<em>movement modes</em>).</p>

<p>One major challenge in this context is the extraction of movement patterns
emerging from the observed data, considering trajectories that share similar
movement modes.
This issue can be restated from a machine learning point of view as a
large-scale clustering task.
This tasks involves the definition of clustering methods
that can handle such complex data while being efficient on large databases,
and that both cluster trajectories as a whole and detect common
sub-trajectories.</p>

<h3 id="model">Model</h3>

<p>We define a parametric framework to model trajectory data,
<em>i.e.</em> sequences of geographical positions recorded through time.
The modeling framework aims to account for two levels of heterogeneity possibly
present in trajectory data:</p>

<ol>
  <li>heterogeneity of a vessel’s movement within a single trajectory, and</li>
  <li>heterogeneity between observed trajectories of several vessels.</li>
</ol>

<p>Following a common paradigm, we assume that a moving vessel’s trajectory
is a heterogeneous sequence of patterns that we call <em>movement modes</em>.
Different movement modes along a trajectory refer to different ways of moving
in terms of velocity distribution, reflecting different behaviors, activities,
or routes.
It is assumed that a given movement mode can be adopted by several vessels.</p>

<p>As done in <a class="citation" href="#gurarie2017correlated">(Gurarie et al., 2017)</a>, we characterize
movement modes using a specific correlated velocity model, defined in a
continuous-time framework, namely the Ornstein-Uhlenbeck Process
<a class="citation" href="#uhlenbeck1930theory">(Uhlenbeck &amp; Ornstein, 1930)</a> (OUP).
One important property of the OUP is that, under mild conditions,
the velocity process is an asymptotically stationary Gaussian Process, which
can be visualized in the following animation:</p>

<p>```python tags=[“hide_input”]
import matplotlib.pyplot as plt
from matplotlib import animation
from IPython.display import HTML
import numpy as np
import scipy.linalg</p>

<p>plt.ion()</p>

<p>def gen_animation(Vt, mu):
    plt.text(x=mu[0] + .5, y=mu[1] + 1.5,
             s=”Asymptotic distribution:\n$\mathcal{N}(\mu, S)$”,
             fontsize=16)
    line, = plt.plot([], [], ‘rx-‘, zorder=0)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># initialization function
def init():
  line.set_data([], [])
  return (line,)

# animation function
def animate(t):
  line.set_data(Vt[:t, 0], Vt[:t, 1])
  return (line,)

anim = animation.FuncAnimation(fig, animate, init_func=init,
                               frames=Vt.shape[0],
                               interval=20, blit=True)
return anim
</code></pre></div></div>

<p>def plot_gaussian(mu, sigma, xlim, ylim):
    N = 100
    X = np.linspace(xlim[0], xlim[1], N)
    Y = np.linspace(ylim[0], ylim[1], N)
    X, Y = np.meshgrid(X, Y)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Pack X and Y into a single 3-dimensional array
pos = np.empty(X.shape + (2,))
pos[:, :, 0] = X
pos[:, :, 1] = Y

def multivariate_gaussian(pos):
    n = mu.shape[0]
    Sigma_det = np.linalg.det(sigma)
    Sigma_inv = np.linalg.inv(sigma)
    N = np.sqrt((2*np.pi)**n * Sigma_det)
    # This einsum call calculates (x-mu)T.Sigma-1.(x-mu) in a vectorized
    # way across all the input variables.
    fac = np.einsum('...k,kl,...l-&gt;...', pos-mu, Sigma_inv, pos-mu)

    return np.exp(-fac / 2) / N

# The distribution on the variables X, Y packed into pos.
Z = multivariate_gaussian(pos)

# Create a contour plot
plt.contour(X, Y, Z, levels=5, colors=["k"]) ```
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">simulate_oup</span><span class="p">(</span><span class="n">V0</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">):</span>
    <span class="s">"""An Ornstein Uhlenbeck is a solution of:

    dX(t) = </span><span class="err">\</span><span class="s">Gamma (X(t)−</span><span class="err">\</span><span class="s">mu) dt + </span><span class="err">\</span><span class="s">Sigma dW(t), X0=x0

    In this case, the solution is a Markov process, with an
    explicit transition law:

    X(t+</span><span class="err">\</span><span class="s">Delta) | {X(t)=x_t} </span><span class="err">\</span><span class="s">sim </span><span class="err">\</span><span class="s">mathcal{N}(m_</span><span class="err">\</span><span class="s">Delta,V_</span><span class="err">\</span><span class="s">Delta)

    with:

    m_</span><span class="err">\</span><span class="s">Delta = </span><span class="err">\</span><span class="s">mu + </span><span class="err">\</span><span class="s">exp(−</span><span class="err">\</span><span class="s">Gamma </span><span class="err">\</span><span class="s">Delta)(x_t−</span><span class="err">\</span><span class="s">mu)

    V_</span><span class="err">\</span><span class="s">Delta = S − </span><span class="err">\</span><span class="s">exp(−</span><span class="err">\</span><span class="s">Gamma </span><span class="err">\</span><span class="s">Delta) S </span><span class="err">\</span><span class="s">exp(−</span><span class="err">\</span><span class="s">Gamma </span><span class="err">\</span><span class="s">Delta)^T

    vec(S)=(</span><span class="err">\</span><span class="s">Gamma </span><span class="err">\</span><span class="s">oplus </span><span class="err">\</span><span class="s">Gamma) − 1 vec(</span><span class="err">\</span><span class="s">Sigma </span><span class="err">\</span><span class="s">Sigma^T)
    """</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">exp_g</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm</span><span class="p">(</span><span class="o">-</span><span class="n">delta_t</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">)</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">gamma</span><span class="p">),</span>
        <span class="n">sigma</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sigma</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">v_delta</span> <span class="o">=</span> <span class="n">S</span> <span class="o">-</span> <span class="n">exp_g</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exp_g</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
        <span class="n">V_prev</span> <span class="o">=</span> <span class="n">V0</span> <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">samples</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">m_delta</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exp_g</span><span class="p">,</span> <span class="n">V_prev</span><span class="p">)</span>
        <span class="n">samples</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">m_delta</span><span class="p">,</span>
                                                   <span class="n">cov</span><span class="o">=</span><span class="n">v_delta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">samples</span>


<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">dt</span> <span class="o">=</span> <span class="mf">.05</span>
<span class="n">n_times</span> <span class="o">=</span> <span class="mi">300</span>  <span class="c1"># Number of timestamps
</span><span class="n">d</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># UOP parameters
</span><span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]])</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span>

<span class="n">Vt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_times</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
<span class="n">Vt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">])</span>
<span class="n">Vt</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">simulate_oup</span><span class="p">(</span><span class="n">V0</span><span class="o">=</span><span class="n">Vt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
                      <span class="n">delta_t</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="n">n_times</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">"X-Velocity"</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">"Y-Velocity"</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>
<span class="c1"># Asymptotic distribution of the OUP is
# N(mu, S) (see definition of S above)
</span><span class="n">S</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">gamma</span><span class="p">),</span>
    <span class="n">sigma</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sigma</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span>
<span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
<span class="n">plot_gaussian</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">sqrtm</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>

<span class="n">anim</span> <span class="o">=</span> <span class="n">gen_animation</span><span class="p">(</span><span class="n">Vt</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="n">HTML</span><span class="p">(</span><span class="n">anim</span><span class="o">.</span><span class="n">to_jshtml</span><span class="p">())</span>
</code></pre></div></div>

<h3 id="parameter-estimation">Parameter estimation</h3>

<p>In order to perform scalable parameter inference and clustering of both
trajectories and GPS observations (into movement modes), we adopt a pragmatic
two step approach that takes advantage of the inherent properties of the OUP:</p>

<ol>
  <li>A first dual clustering is performed based on a simpler independent
Gaussian Mixture Model, in order to estimate potential movement modes and
trajectory clusters: it removes within mode autocorrelation in
the inference, and therefore facilitates the computations, yet it does not rely
on any temporal or sequential information.
Here again, we use a Hierarchical Dirichlet Process as a model for this
two-level clustering, hence allowing for infinite mixtures of both movement
modes and trajectory clusters.
The Gaussian hypothesis in this case is in line with our choice of the OUP as
our velocity process, since the OUP stationary distribution is Gaussian.</li>
  <li>Among the estimated movement modes, only those meeting a temporal consistency
constraint are kept.
Parameters of these consistent movement modes are then estimated, and used to
reassign observations that were assigned to inconsistent movement modes (<em>i.e.</em>
movement modes that do not last long enough to be considered reliable).
It ensures that only trajectory segments for which the stationary distribution
is reached are kept to estimate movement modes.</li>
</ol>

<p>The resulting consistent movement mode concept allows one to (1) have a good
estimation of OUP parameters within a movement mode (as a consistent sequence
will often be related to a large amount of points) and (2) filter out
“noise” movement modes gathering few observations in a temporally
inconsistent manner.</p>

<p>Parameter estimation for Step 1 described above is performed through stochastic
variational inference (SVI) to allow scalability to large datasets of AIS data,
and movement mode parameter estimation is performed using standard tools from
the OUP literature.</p>

<p>The clustering
step is predominant in the overall computational complexity at inference time,
since the OUP parameter estimation can be performed independently for each
movement mode.
It is quasilinear in the number of
observations and, as stochastic variational inference is used, parts of the
computations involved can easily be distributed.</p>

<h3 id="results">Results</h3>

<p>We have provided <a href="https://github.com/rtavenar/ushant_ais">a dataset</a> of several
millions of observations in the AIS context.
This dataset is used in <a class="citation" href="#gloaguen2020">(Gloaguen, Chapel, Friguet, &amp; Tavenard, 2020)</a> to validate our model
qualitatively (through visual
analysis of extracted movement modes and trajectory clusters) and compare it to
a standard $k$-means clustering.
We intend to make this dataset a reference for future competitive methods to
compare on a
real-world large-scale trajectory dataset.</p>

<h2 id="references">References</h2>

<ol class="bibliography"><li><span id="EmonetCVPR2011">Emonet, R., Varadarajan, J., &amp; Odobez, J.-M. (2011). Extracting and Locating Temporal Motifs in Video Scenes Using a Hierarchical Non Parametric Bayesian Model. In <i>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</i>.</span></li>
<li><span id="tavenard:hal-00872048">Tavenard, R., Emonet, R., &amp; Odobez, J.-M. (2013). Time-Sensitive Topic Models for Action Recognition in Videos. In <i>Proceedings of the IEEE International Conference on Image Processing</i>. Melbourne, Australia.</span></li>
<li><span id="garnier2016exploiting">Garnier, B., &amp; Napoli, A. (2016). Exploiting the Potential of the Future “Maritime Big Data.” In <i>Maritime Knowledge Discovery and Anomaly Detection Workshop</i>.</span></li>
<li><span id="gurarie2017correlated">Gurarie, E., Fleming, C. H., Fagan, W. F., Laidre, K. L., Hernández-Pliego, J., &amp; Ovaskainen, O. (2017). Correlated velocity models as a fundamental unit of animal movement: synthesis and applications. <i>Movement Ecology</i>, <i>5</i>(1), 13.</span></li>
<li><span id="uhlenbeck1930theory">Uhlenbeck, G. E., &amp; Ornstein, L. S. (1930). On the theory of the Brownian motion. <i>Physical Review</i>, <i>36</i>(5), 823.</span></li>
<li><span id="gloaguen2020">Gloaguen, P., Chapel, L., Friguet, C., &amp; Tavenard, R. (2020). <i>Scalable clustering of segmented trajectories within a continuous time framework. Application to maritime traffic data.</i></span></li></ol>

            </div>
            <div class="c-textbook__footer" id="textbook_footer">
              
<nav class="c-page__nav">
  

  
</nav>

              <footer>
  <p class="footer"></p>
</footer>

            </div>

        </div>
      </main>
    </div>
  </body>
</html>
